fonction push_swap(pile_a, pile_b):
    si pile_a contient moins de 2 éléments:
        retourner pile_a  // Aucun tri nécessaire

    diviser_pile_en_groupes(pile_a, pile_b)
    réinsérer_dans_A(pile_b, pile_a)

fonction diviser_pile_en_groupes(pile_a, pile_b):
    // Choisir un pivot (par exemple, la médiane ou les quartiles)
    pivot = choisir_pivot(pile_a)

    // Diviser les éléments de pile_a en fonction du pivot
    tant que pile_a n'est pas vide:
        si élément_en_tête(pile_a) < pivot:
            // Pousser vers B
            pb(pile_a, pile_b)
        sinon:
            // Garde dans A (rotation)
            ra(pile_a)

fonction réinsérer_dans_A(pile_b, pile_a):
    // Réinsérer les éléments de B dans A par ordre décroissant
    tant que pile_b n'est pas vide:
        élément = trouver_max(pile_b)

        // Trouver la meilleure place pour l'élément dans A
        calculer_rotation(pile_a, élément)

        // Réinsérer dans A
        pa(pile_a, pile_b)

fonction choisir_pivot(pile_a):
    // Par exemple, on peut choisir le pivot comme étant la médiane
    // ou tout autre heuristique
    retourner médiane(pile_a)

fonction trouver_max(pile_b):
    // Trouver le plus grand élément dans pile_b
    retourner max(pile_b)

fonction calculer_rotation(pile_a, élément):
    // Calculer où l'élément doit être inséré dans A
    // en fonction des rotations nécessaires
    distance = calculer_distance(pile_a, élément)

    si distance > 0:
        // Rotation à droite
        ra(pile_a)
    sinon:
        // Rotation à gauche
        rra(pile_a)

fonction calculer_distance(pile_a, élément):
    // Calculer la distance entre l'élément et l'endroit optimal dans pile_a
    // Distance optimale : place la valeur à la bonne position dans A
    retourner distance

